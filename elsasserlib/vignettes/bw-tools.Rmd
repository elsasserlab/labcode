---
title: "BigWig tools"
author: "Carmen Navarro"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
    toc: true
  
vignette: >
  %\VignetteIndexEntry{bw-tools}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteDepends{elsasserlib}
  %\VignetteEncoding{UTF-8}
  \usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE}
library(elsasserlib)
library(ggplot2)
library(rtracklayer)
```

## Summary

This module contains functions to handle BigWig files to perform analyses we 
usually do, like summarizing the information across *loci* in a `BED` file or making
a binned analysis of a set of `BigWig` files.

## Binned analysis

This includes functionality to make bins as `GRanges` objects and intersect
`BigWig` files with those.

### Making a GRanges object as a binned genome

To do this, you only need to call the function `build_bins`:

```{r} 
mm9.genome.bins.10000 <- build_bins(bsize=10000, genome="mm9")

head(mm9.genome.bins.10000)
```

`build_bins` relies on `GenomeInfoDb` package and additional data contained in
`BSgenome.Mmusculus.UCSC.mm9` and `BSgenome.Hsapiens.UCSC.hg38`, from which it
takes sequence info necessary to build the bins. I included these because in
the lab we mostly use these two references. If you want to use another
genome, you will have to make the tiling yourself. This is pretty easy, really
(see documentation on `tileGenome` to do this). 

### Making a binned summary of a BigWig file

You can use the function `bw_bins` for this.

```{r} 
# Example bw file included in the package.
# Note: this should be a path for an actual file.
bw.file <- system.file("extdata", "example.1000bs.bw", package = "elsasserlib")

# Now we bin it
binned.score <- bw_bins(bw.file, bsize=10000)

head(binned.score)
```

Yes, not very informative, since signal at the first bins is zero. To test that
this actually worked, we can plot the scores.

```{r, warning=FALSE} 
# Convert to dataframe
df <- as.data.frame(binned.score)

ggplot(df, aes(y=score)) + 
  geom_boxplot() + 
  ylim(0,20) +
  theme_elsasserlab_screen()
```

Note that the `bw_bins` operation is **not immediate**. It will take some seconds to execute
in a regular laptop. In my experience, it goes between 30-40 seconds depending
on the size of the `bigWig` file for bin sizes of `5000`-`10000`. If you want
higher resolutions, consider precomputing these values beforehand.

## Locus-based analysis

You can also intersect a `bigWig` file with a set of loci specified in a `BED`
file using `bw_bed`:

```{r} 
# Example bw file included in the package.
# Note: this should be a path for an actual file.
bw.file <- system.file("extdata", "example.1000bs.bw", package = "elsasserlib")
bed.file <- system.file("extdata", "ChromHMM7_subsample.bed", package = "elsasserlib")

# We intersect these two files
summary.score <- bw_bed(bw.file, bed.file, per.locus.stat = "mean")

# We get a GRanges object which one score per locus
head(summary.score)
```

Note the `per.locus.stat` parameter is a parameter that is passed to `rtracklayer`.
They provide functionality to calculate min, max, mean, sd and coverage, but the
meaning of coverage results is not clear to me, so I would recommend using mean,
which is the actual mean of the coverage calculated in the analysed bin.

When intersecting a `BED` file with a `BigWig` file, sometimes we have a `name`
field that has some category, for instance:

```{r} 
# This import is `rtracklayer` import
loci <- import(bed.file)

table(as.factor(loci$name))
```

In this case, we may be interested in obtaining a summarized table. This can
be done with the same function:

```{r} 
# We intersect these two files
summary.score <- bw_bed(bw.file, bed.file, per.locus.stat = "mean", aggregate.by = mean)

# We get a GRanges object which one score per locus
summary.score
```

Note the difference between `per.locus.stats`, which aggregates data within a 
single bin or loci, and `aggregate.by`, which calculates an aggregated value
based on the whole distribution of bins that belong to a category. For instance,
we can have **mean** coverage *per locus* and calculate the **median** of all 
those, to avoid influence of outliers:

```{r} 
# We intersect these two files, but this time we summarize by median
median.score <- bw_bed(bw.file,
                       bed.file,
                       per.locus.stat="mean",
                       aggregate.by=median)

# We get a GRanges object which one score group of loci
median.score
```

With this info you could already have an idea of which loci groups have more
coverage than others:

```{r} 
ggplot(summary.score, aes(x=name, y=score, fill=name)) + 
  geom_bar(stat='identity') + 
  ylab('Mean coverage') +
  xlab('ChromHMM7 (subsampled)') +
  theme_elsasserlab_screen()
```

## Computing binned values on several bigWig files

Many times you will want to look at several `bigWig` files at the same time.
For this, you can call `multi_bw_ranges`. It takes a list of `bigWig` files
and *intersects* them with a `GRanges` object.

## More documentation
Even though this is a mixed-code package, it is documented as any proper R 
package is, which means when you're programming you can access help
for functions using `?` operator:

```{r results = "asis"} 
print(?bw_bins)
```

