---
title: "BigWig tools"
author: "Carmen Navarro"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
    toc: true
  
vignette: >
  %\VignetteIndexEntry{bw-tools}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteDepends{elsasserlib}
  %\VignetteEncoding{UTF-8}
  \usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE}
library(elsasserlib)
library(ggplot2)
library(rtracklayer)
```

## Summary

This module contains functions to handle BigWig files to perform analyses we 
usually do, like summarizing the information across *loci* in a `BED` file or making
a binned analysis of a set of `BigWig` files.

## Binned analysis

You can use the function `bw_bins` to average a `bigWig` file over a set of 
fixed-size bins genome-wide.

```{r} 
# Example bw file included in the package.
bw.file <- system.file("extdata", "ES_H33_00h_rep1_hoxc.bw", package = "elsasserlib")
selection <- GRanges(seqnames='chr15', range=c(102691597,102965638))
# Now we bin it
binned.score <- bw_bins(bw.file,
                        colnames=c('score'),
                        bsize=100,
                        selection=selection)

head(binned.score)
```


Note that the `bw_bins` operation is **not immediate**. It will take some seconds to execute
in a regular laptop. In my experience, it goes between 30-40 seconds depending
on the size of the `bigWig` file for bin sizes of `5000`-`10000`. If you want
higher resolutions, consider precomputing these values beforehand.

`bw_bins` supports multi `bigWig` file, so if you provide several files, you will
get a `GRanges` object with several columns, one per file.

Additional parameters of `bw_bins` function are `per.locus.stat`, that tells
`bw_bins` which function is used to aggregate the values within a bin or locus.


```{r} 
# Example bw file included in the package.
# Note: this should be a path for an actual file.
bw.file <- system.file("extdata", "ES_H33_00h_rep1_hoxc.bw", package = "elsasserlib")
bw.file.2 <- system.file("extdata", "ES_H33_03h_rep1_hoxc.bw", package = "elsasserlib")
bw.file.3 <- system.file("extdata", "ES_H33_12h_rep1_hoxc.bw", package = "elsasserlib")
selection <- GRanges(seqnames='chr15', range=c(102691597,102965638))
# Now we bin it
# The files are actually the same, so we need to provide column names to avoid
# confusion:
binned.score <- bw_bins(c(bw.file, bw.file.2, bw.file.3),
                        colnames=c('file1', 'file2', 'file3'),
                        bsize=100,
                        selection=selection)

head(binned.score)
```


## Locus-based analysis

You can also intersect a `bigWig` file with a set of loci specified in a `BED`
file using `bw_bed`:

```{r} 
# Example bw file included in the package.
# Note: this should be a path for an actual file.
bw.file <- system.file("extdata", "ES_H33_00h_rep1_hoxc.bw", package="elsasserlib")
bed.file <- system.file("extdata", "chromhmm_hoxc.bed", package="elsasserlib")

# We intersect these two files
summary.score <- bw_bed(bw.file, bed.file, per.locus.stat = "mean")

# We get a GRanges object which one score per locus
head(summary.score)
```

Note the `per.locus.stat` parameter is a parameter that is passed to `rtracklayer`.
They provide functionality to calculate min, max, mean, sd and coverage, but the
meaning of coverage results is not clear to me, so I would recommend using mean,
which is the actual mean of the coverage calculated in the analysed bin.

When intersecting a `BED` file with a `BigWig` file, sometimes we have a `name`
field that has some category, for instance:

```{r} 
# This import is `rtracklayer` import
loci <- import(bed.file)

table(as.factor(loci$name))
```

In this case, we may be interested in obtaining a summarized table. This can
be done with the same function:

```{r} 
# We intersect these two files
summary.score <- bw_bed(bw.file,
                        bed.file,
                        colnames=c('score'),
                        per.locus.stat = "mean",
                        aggregate.by=mean)

# We get a GRanges object which one score per locus
summary.score
```

Note the difference between `per.locus.stats`, which aggregates data within a 
single bin or loci, and `aggregate.by`, which calculates an aggregated value
based on the whole distribution of bins that belong to a category. For instance,
we can have **mean** coverage *per locus* and calculate the **median** of all 
those, to avoid influence of outliers:

```{r} 
# We intersect these two files, but this time we summarize by median
median.score <- bw_bed(bw.file,
                       bed.file,
                       per.locus.stat="mean",
                       aggregate.by=median)

# We get a GRanges object which one score group of loci
median.score
```

With this info you could already have an idea of which loci groups have more
coverage than others:

```{r} 
ggplot(as.data.frame(summary.score), aes(x=name, y=score, fill=name)) + 
  geom_bar(stat='identity') + 
  ylab('Mean coverage') +
  xlab('ChromHMM7 (subsampled)') +
  theme_elsasserlab_screen()
```


## Computing values on several bigWig files

Many times you will want to look at several `bigWig` files at the same time.
Both functions `bw_bins` and `bw_bed` accept both single `bigWig` files and
lists, as shown above.

## Returning type of bigWig functions

The value returned is specified in each function documentation, but, in general,
a function will return `GRanges` objects when possible, to keep the structure
of the original `BED` file or bins.

However, there are cases where this is not possible or meaningful, for instance,
when calling `bw_bed` with an `aggregate.by` parameter, the result is an 
aggregated score of *loci* labeled with a certain value, so we lose the 
`locus` information. In these cases, a `DataFrame` is returned.

## Other useful functions

### Making a GRanges object as a binned genome

To do this, you only need to call the function `build_bins`:

```{r} 
mm9.genome.bins.10000 <- build_bins(bsize=10000, genome="mm9")

head(mm9.genome.bins.10000)
```

`build_bins` relies on `GenomeInfoDb` package and additional data contained in
`BSgenome.Mmusculus.UCSC.mm9` and `BSgenome.Hsapiens.UCSC.hg38`, from which it
takes sequence info necessary to build the bins. I included these because in
the lab we mostly use these two references. If you want to use another
genome, you will have to make the tiling yourself. This is pretty easy, really
(see documentation on `tileGenome` to do this). 

## More documentation
Even though this is a mixed-code package, it is documented as any proper R 
package is, which means when you're programming you can access help
for functions using `?` operator: `?bw_bins`.
